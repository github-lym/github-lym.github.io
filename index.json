[{"categories":["筆記"],"content":"第一篇文章","date":"2022-03-31 00:12:00 Thursday","objectID":"/posts/2022/gitcopyfromotherbranch/","tags":["Git"],"title":"Git從其他分支Copy檔案到工作目錄","uri":"/posts/2022/gitcopyfromotherbranch/"},{"categories":["筆記"],"content":"今天Blog用了兩個主題， 所以需要不停切換。 有需要把其他分支的檔案copy到主分支， 查了一下，發現在Stack Overflow網站的答案非常棒。 git checkout 其他分支 . 這動作目前tortoisegit我還沒發現該怎麼做， git指令操作果然還是王道。 ","date":"2022-03-31 00:12:00 Thursday","objectID":"/posts/2022/gitcopyfromotherbranch/:0:0","tags":["Git"],"title":"Git從其他分支Copy檔案到工作目錄","uri":"/posts/2022/gitcopyfromotherbranch/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(執行批次檔並將視窗分別擷圖)","date":"2022-03-30 14:02:41 Wednesday","objectID":"/posts/2022/focussnapshot/","tags":["懶人上班程式","CSharp","WinForm"],"title":"多線程執行批次檔並將視窗分別擷圖(導向輸出log)","uri":"/posts/2022/focussnapshot/"},{"categories":["懶人上班程式"],"content":"駐點在機關時得幫其他廠商定期與不定期更新網站。 更新這件事是沒什麼問題，廠商已經盡量簡化，編譯包版後執行批次檔就可以了。 只不過就是批次檔有點多，每個網站一個近40個。 負責上版的主機效能的很棒，可以一次執行20個左右沒問題。 但Windows有個內建設定─不得一次執行超過15個批次檔， 這樣本可兩次跑完卻分三次跑，不是很願意。 雖這可以藉由改登錄檔處理，但在公家機關的主機改登錄檔怕會有些不必要的麻煩。 且每個批次檔要截圖為證。 這就有點麻煩，那麼多個視窗，一個不小心就漏了或搞不清是否已擷過圖。 於是就寫了這個程式， 既可以多線程大量執行批次檔，且可以讓批次檔視窗輪流跑到最前端並擷圖。 =\u003e 初版執行畫面 \u003c= 後來發現有時批次檔執行不見得會成功， 但程式截圖那時根本也不可能一一細看， 最後改成把命令提示字元輸出導向成文字檔， 事後再去檢查文字檔的訊息， 若失敗就再一次執行相對應的批次檔。 ","date":"2022-03-30 14:02:41 Wednesday","objectID":"/posts/2022/focussnapshot/:0:0","tags":["懶人上班程式","CSharp","WinForm"],"title":"多線程執行批次檔並將視窗分別擷圖(導向輸出log)","uri":"/posts/2022/focussnapshot/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(自動去掉文字前後空白)","date":"2022-03-30 14:02:13 Wednesday","objectID":"/posts/2022/trimcopy/","tags":["懶人上班程式","CSharp","WinForm"],"title":"去掉文字前後空白","uri":"/posts/2022/trimcopy/"},{"categories":["懶人上班程式"],"content":"做客服工程師那會，每天都要查詢資料庫。 但資料庫有個欄位當初設計為char而非varchar， 複製這欄位做之後的查詢還得去除掉後面的空白造成困擾。 當時的想法是如果可以在剪貼簿上把前後空白刪掉就好了。 但即便對現在的我來說仍是有困難的，還好有得抄。 找到類似的稍微改一下達到我要的， 加上可以將程式縮到工作列與點擊切換啟動與否。 //hide form from Alt-Tab dialog protected override CreateParams CreateParams { get { // Turn on WS_EX_TOOLWINDOW style bit CreateParams cp = base.CreateParams; cp.ExStyle |= 0x80; return cp; } } //form invisible protected override void OnVisibleChanged(EventArgs e) { base.OnVisibleChanged(e); this.Visible = false; } public Form1() { InitializeComponent(); nextClipboardViewer = (IntPtr)SetClipboardViewer((int)this.Handle); //this.ShowInTaskbar = false; //不顯示在底下工具列(改設定在form屬性) this.Hide(); //隱藏視窗 this.notifyIcon1.ContextMenu = new ContextMenu(); this.notifyIcon1.ContextMenu.MenuItems.Add(new MenuItem(\"EXIT\", new EventHandler(Exit))); notifyIcon1.Icon = Properties.Resources.checkIcon; } private void notifyIcon1_MouseClick(object sender, MouseEventArgs e) { if (trimWorking == true) { trimWorking = false; notifyIcon1.Icon = Properties.Resources.unCheckIcon; notifyIcon1.ShowBalloonTip(100, null, \"Stop Working\", ToolTipIcon.Warning); } else if (trimWorking == false) { trimWorking = true; notifyIcon1.Icon = Properties.Resources.checkIcon; notifyIcon1.ShowBalloonTip(100, null, \"Start Working\", ToolTipIcon.Warning); } } private void Exit(object sender, EventArgs e) { this.Close(); } 雖然偶爾會跳出異常，不過方便多了。 如今回過頭來看，還真的是有些地方可以改改看看還會不會跳出異常。 ","date":"2022-03-30 14:02:13 Wednesday","objectID":"/posts/2022/trimcopy/:0:0","tags":["懶人上班程式","CSharp","WinForm"],"title":"去掉文字前後空白","uri":"/posts/2022/trimcopy/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(用forfiles刪除一個月以上logs)","date":"2022-03-29 14:02:44 Tuesday","objectID":"/posts/2022/del_logs_forfiles/","tags":["懶人上班程式","cmd"],"title":"用forfiles刪除過期檔案","uri":"/posts/2022/del_logs_forfiles/"},{"categories":["懶人上班程式"],"content":"之前有聽過forfiles的大名，但沒機會用。 這次襄理要我寫個批次檔刪除IIS上的logs，只保留一個月內的。 立刻著手抄研究一下。 我當時照抄了一份也試了覺得可行， 事後發現在有子資料夾的情況下，只有刪除檔案，不會刪除子資料夾。 也發現子資料夾的時間都被改變了，可能是刪除檔案的關係。 forfiles -p \"D:\\logfiles\" -m *.* -d -30 -c \"cmd /c del /q @path\" forfiles -p \"D:\\logfiles\" -d -30 -c \"cmd /c IF @isdir == TRUE rd /S /Q @path\" 到最後還是在網上找到答案。 附上微軟官方說明。 ","date":"2022-03-29 14:02:44 Tuesday","objectID":"/posts/2022/del_logs_forfiles/:0:0","tags":["懶人上班程式","cmd"],"title":"用forfiles刪除過期檔案","uri":"/posts/2022/del_logs_forfiles/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(使用robocopy備份)","date":"2022-03-29 14:02:08 Tuesday","objectID":"/posts/2022/website_backup/","tags":["懶人上班程式","cmd"],"title":"使用robocopy站台備份","uri":"/posts/2022/website_backup/"},{"categories":["懶人上班程式"],"content":"站台要更新之前一定得備份。 之前土炮的作法，當然是在備份區建立一個日期資料夾，然後複製貼上。 這麼做也不是不行，但logs資料其實沒必要備份， 再加上使用windows複製不夠有效率，我又把腦筋動到了robocopy上。 :@Echo Off Set \"sd=C:\\inetpub\\CMS\" Set \"dd=C:\\inetpub\\CMS_BACKUP\" Set \"ex1=C:\\inetpub\\CMS\\WebApi\\Logs\" :這段是用來產生當日日期 for /f \"tokens=2 delims==\" %%a in ('wmic OS Get localdatetime /value') do set \"dt=%%a\" set \"YY=%dt:~2,2%\" \u0026 set \"YYYY=%dt:~0,4%\" \u0026 set \"MM=%dt:~4,2%\" \u0026 set \"_DD=%dt:~6,2%\" set \"HH=%dt:~8,2%\" \u0026 set \"Min=%dt:~10,2%\" \u0026 set \"Sec=%dt:~12,2%\" set \"datestamp=%YYYY%%MM%%_DD%\" \u0026 set \"timestamp=%HH%%Min%%Sec%\" \u0026 set \"fullstamp=%YYYY%-%MM%-%_DD%_%HH%%Min%-%Sec%\" :echo datestamp: \"%datestamp%\" :echo timestamp: \"%timestamp%\" :echo fullstamp: \"%fullstamp%\" RoboCopy \"%sd%\" \"%dd%\\CMS_BACKUP_%datestamp%\\CMS\" /MIR /E /R:5 /W:5 /TBD /NP /NFL /V /MT:32 /XD \"%ex1%\" pause 一開始就設定好來源與目標，還有排除的資料夾。 /mir 鏡像目錄樹狀結構 (相當於 /e plus /purge) 。 使用這個選項搭配 /e 選項和目的地目錄，會覆寫目的地目錄安全性設定。 /e 複製子目錄。 此選項會自動包含空的目錄。 /s 複製子目錄。 此選項會自動排除空白目錄。 /r:\u003cn\u003e 指定失敗複製的重試次數。N的預設值為 1000000 (1000000 重試) /w:\u003cn\u003e 指定重試之間的等待時間 (以秒為單位)。 N的預設值是 30 (等候時間30秒) /tbd 指定系統將等待定義共用名稱 (重試錯誤 67) 。 :看不懂，英文是寫這樣 `Wait for share names To Be Defined (retry error 67) /np 指定將不會顯示複製作業的進度 (到目前為止複製的檔案或目錄數目)。` 速度比較快 /nfl 指定不會記錄檔案名稱。 /v 產生詳細資訊輸出，並顯示所有略過的檔案。 /MT[:n] 使用 n 個執行緒建立多執行緒複製。 /xd \u003cdirectory\u003e[ ...] 排除符合指定名稱和路徑的目錄。 其實在寫這篇我才比較了解，還有用錯的。 還是去微軟官方看比較詳盡。 ","date":"2022-03-29 14:02:08 Tuesday","objectID":"/posts/2022/website_backup/:0:0","tags":["懶人上班程式","cmd"],"title":"使用robocopy站台備份","uri":"/posts/2022/website_backup/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(FTP抓取資料庫備份)","date":"2022-03-29 13:01:44 Tuesday","objectID":"/posts/2022/ftpdb/","tags":["懶人上班程式","CSharp","Console"],"title":"以FTP抓取資料庫備份","uri":"/posts/2022/ftpdb/"},{"categories":["懶人上班程式"],"content":"MSSQL資料庫每天都會備份，每週一得還原最新備份在另一台當歷史資料查詢。 通常資料庫備份容量不會太小， 當時每週一早上都先進機房後，再花個一二十分鐘下載到指定主機再還原。 一整個流程下來都要花個三四十分鐘。 覺得這時間頗浪費，於是懶人病發作寫了這個當排程。 讓我可以在進機房之前就把備份檔下載好，起碼省去一半的時間。 微軟這邊有上傳詳細教學： using System; using System.IO; using System.Net; namespace Examples.System.Net { public class WebRequestGetExample { public static async Task Main() { // Get the object used to communicate with the server. FtpWebRequest request = (FtpWebRequest)WebRequest.Create(\"ftp://www.contoso.com/test.htm\"); request.Method = WebRequestMethods.Ftp.UploadFile; // This example assumes the FTP site uses anonymous logon. request.Credentials = new NetworkCredential(\"anonymous\", \"janeDoe@contoso.com\"); // Copy the contents of the file to the request stream. await using FileStream fileStream = File.Open(\"testfile.txt\", FileMode.Open, FileAccess.Read); await using Stream requestStream = request.GetRequestStream(); await fileStream.CopyToAsync(requestStream); using FtpWebResponse response = (FtpWebResponse)request.GetResponse(); Console.WriteLine($\"Upload File Complete, status {response.StatusDescription}\"); } } } 我是下載，所以 request.Method = WebRequestMethods.Ftp.ListDirectory; 使用binary傳輸 request.UseBinary = true; ","date":"2022-03-29 13:01:44 Tuesday","objectID":"/posts/2022/ftpdb/:0:0","tags":["懶人上班程式","CSharp","Console"],"title":"以FTP抓取資料庫備份","uri":"/posts/2022/ftpdb/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(查詢排程狀態)","date":"2022-03-29 11:11:43 Tuesday","objectID":"/posts/2022/taskscheduler/","tags":["懶人上班程式","CSharp","Console"],"title":"查詢排程狀態","uri":"/posts/2022/taskscheduler/"},{"categories":["懶人上班程式"],"content":"因代理同事工作，才知道他每天需記錄排程是否順利。 要特地進機房看某主機排程是否有順利進行。 因資安問題並沒有開放遠端連線，所以只能用這種沒效率的方法。 我就找資料寫了這程式。 可以指定排程名稱產生log。 再用FTP連到該主機看該log(好在FTP沒被禁)，省去進機房的麻煩。 產生的logTaskScheduler \"\r產生的log\r 取得排程資料 TaskService taskService = new TaskService(); TaskCollection taskCollection = taskService.GetFolder(@\"\\\").GetTasks(); log.WriteLine(\"排程:{0},執行狀態:{1}\", taskCollection[j].Name, taskCollection[j].LastTaskResult); log.WriteLine(\"最後執行時間:{0},下次執行時間:{1}\", taskCollection[j].LastRunTime, taskCollection[j].NextRunTime.ToString()); ","date":"2022-03-29 11:11:43 Tuesday","objectID":"/posts/2022/taskscheduler/:0:0","tags":["懶人上班程式","CSharp","Console"],"title":"查詢排程狀態","uri":"/posts/2022/taskscheduler/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(查詢磁碟容量)","date":"2022-03-29 11:11:30 Tuesday","objectID":"/posts/2022/drivefreespace/","tags":["懶人上班程式","CSharp","Console"],"title":"查詢磁碟容量","uri":"/posts/2022/drivefreespace/"},{"categories":["懶人上班程式"],"content":"因代理同事工作，才知道他每天得特地進機房看某主機的硬碟剩餘空間。 沒辦法，一樣沒有遠端連線可直接登入觀看。 可以秀出磁碟空間的寫法，MSDN就有資料所以直接照抄。 好在FTP沒被擋，可排程產生log，再用FTP連到該主機看。 產生的logDriveFreeSpace \"\r產生的log\r 取得磁碟資料 DriveInfo[] allDrives = DriveInfo.GetDrives(); 列出 foreach (DriveInfo d in allDrives) { if (!File.Exists(logFullPath)) log = new StreamWriter(logFullPath); else log = File.AppendText(logFullPath); log.WriteLine(\"Drive {0}\", d.Name); log.WriteLine(\" Drive type: {0}\", d.DriveType); if (d.IsReady == true) { log.WriteLine(\" Volume label: {0}\", d.VolumeLabel); log.WriteLine(\" File system: {0}\", d.DriveFormat); gb = (float)(d.TotalSize / 1073741824d); log.WriteLine( \" Total size of drive: {0, 15} GBs\", gb); gb = (float)((d.TotalSize - d.AvailableFreeSpace) / 1073741824d); log.WriteLine( \" Used space: {0, 15} GBs\", gb); gb = (float)(d.TotalFreeSpace / 1073741824d); log.WriteLine( \" Total available space: {0, 15} GBs\", gb); log.WriteLine(\"\"); } ","date":"2022-03-29 11:11:30 Tuesday","objectID":"/posts/2022/drivefreespace/:0:0","tags":["懶人上班程式","CSharp","Console"],"title":"查詢磁碟容量","uri":"/posts/2022/drivefreespace/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(整理logs)","date":"2022-03-29 11:11:24 Tuesday","objectID":"/posts/2022/arrangelog/","tags":["懶人上班程式","CSharp","Console"],"title":"整理logs","uri":"/posts/2022/arrangelog/"},{"categories":["懶人上班程式"],"content":"有個系統每天產生的log檔很多。 同樣的，居然沒有以日期資料夾分類整理。 隨著日子過去就越積越多，為了查log光開啟資料夾顯示所有檔案就要等很久。 就寫這程式每天判斷並把log放到依月份的資料夾。要查也方便。 ","date":"2022-03-29 11:11:24 Tuesday","objectID":"/posts/2022/arrangelog/:0:0","tags":["懶人上班程式","CSharp","Console"],"title":"整理logs","uri":"/posts/2022/arrangelog/"},{"categories":["懶人上班程式"],"content":"純粹是看不慣log的資料夾塞得滿滿的從沒整理。","date":"2022-03-29 11:11:24 Tuesday","objectID":"/posts/2022/arrangelog/:0:1","tags":["懶人上班程式","CSharp","Console"],"title":"整理logs","uri":"/posts/2022/arrangelog/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(搬移大量檔案)","date":"2022-03-29 09:09:55 Tuesday","objectID":"/posts/2022/copytofolder/","tags":["懶人上班程式","CSharp","WinForm"],"title":"指定目錄搬移大量檔案","uri":"/posts/2022/copytofolder/"},{"categories":["懶人上班程式"],"content":"維護的系統有提供上傳附件的功能。 也不意外，這功能是一般系統都會有的功能。 大概是開發者沒想過這系統會用那麼久， 上傳的目錄並無額外子目錄，就把所有檔案像大雜燴一樣統統塞一起。 因塞久了硬碟會滿，就得把較舊的檔案搬移。 但一進入資料夾因為檔案太多就快死機了； 為了要備份較舊檔案，檔案開啟後以時間排序又要死一次。 系統的上傳程式我改不了，那我讓備份這邊的輕鬆點，就生出了這程式。 可以指定路徑並依檔案時間判斷移到另一指定路徑， 不再開啟資料夾浪費時間。 初版初版 \"\r初版\r 下方圖片為後來進階版。 全部重寫後效能應有增加，並且增加了依月份產生資料夾功能。 還很騷包附上了進度條(ProgressBar)。 進階版進階版 \"\r進階版\r 當然啦，現在有robocopy應該就比較方便了。 ","date":"2022-03-29 09:09:55 Tuesday","objectID":"/posts/2022/copytofolder/:0:0","tags":["懶人上班程式","CSharp","WinForm"],"title":"指定目錄搬移大量檔案","uri":"/posts/2022/copytofolder/"},{"categories":["懶人上班程式"],"content":"懶人上班程式(批次執行vbs檔並檢查結果)","date":"2022-03-28 22:10:11 Monday","objectID":"/posts/2022/ntpc-organizational-chart/","tags":["懶人上班程式","CSharp","Console","WinForm"],"title":"批次執行vbs檔並檢查結果","uri":"/posts/2022/ntpc-organizational-chart/"},{"categories":["懶人上班程式"],"content":"剛進公司是駐點在公家機關做客服工程師，每天接電話回答系統問題。 除此之外，每天下班為了流程都必須更新該機關組織圖。 前輩寫了一個很神的程式，他寫的vbs可以去抓資料庫的資料， 並產生新的SQL指令(文字檔)可以更新組織圖。 所以我們每天會檢查有異動的組織單位，產生該組織的SQL更新指令。 這產生的問題比較麻煩的點有兩個： 1. 有時資料庫連不上或是一些我不知道的理由，產生的SQL指令並不完全。 2. 要開啟多個文字檔執行SQL指令，頗浪費時間。做完一整套常花快一個鐘頭。 ","date":"2022-03-28 22:10:11 Monday","objectID":"/posts/2022/ntpc-organizational-chart/:0:0","tags":["懶人上班程式","CSharp","Console","WinForm"],"title":"批次執行vbs檔並檢查結果","uri":"/posts/2022/ntpc-organizational-chart/"},{"categories":["懶人上班程式"],"content":"於是，我的懶人病發作了，就寫了進公司的第一支程式。 一開始很單純，既然程式在有異動單位的資料夾產生*.sql檔， 那我把子資料夾的檔案合併成一個再來執行就好。 於是生成了這個。 雖省了一些時間，但並沒解決上述第一個問題。 上圖後來東問西抄問人寫出來的第三版。 當時從Leo那得知執行vbs的寫法： private void _vbs(DirectoryInfo _folder) //執行子目錄底下vbs { vbsfile = _folder.FullName + \"\\\\\" + set.VBSname; Process vbs = new Process(); vbs.StartInfo.FileName = @\"cscript\"; vbs.StartInfo.Arguments = \" \" + vbsfile; vbs.StartInfo.WorkingDirectory = _folder.FullName; vbs.Start(); vbs.WaitForExit(); vbs.Close(); //System.Threading.Thread.Sleep(TimeSpan.FromTicks(set.waitTime)); } 比以前的作業方式簡單又可檢查未產生的檔案並重新產出， 算是個半全自動程式。 以前產生百個檔案以上無法一一檢查的問題迎刃而解， 使用這版本以來，不再有未產出檔案的事發生。 但僅適用於本人上班場所，泛用性不高。 不過省了很多時間，本來一小時的操作變為大約20分鐘左右就搞定下班了。 ","date":"2022-03-28 22:10:11 Monday","objectID":"/posts/2022/ntpc-organizational-chart/:0:1","tags":["懶人上班程式","CSharp","Console","WinForm"],"title":"批次執行vbs檔並檢查結果","uri":"/posts/2022/ntpc-organizational-chart/"},{"categories":null,"content":"將MSSQL Table的Binary檔轉出","date":"2022-03-21 00:12:00 Monday","objectID":"/posts/2022/covert-to-files-from-mssql/","tags":["MSSQL"],"title":"將MSSQL Table的Binary檔轉出","uri":"/posts/2022/covert-to-files-from-mssql/"},{"categories":null,"content":"當時臨時接到這個要求。 先掛載到Server 因Express無法掛超過10GB，請用其他進階版本。 USE[master]GOCREATEDATABASE[tms01p141]ON(FILENAME=N'D:\\DB\\tms01p141.mdf'),(FILENAME=N'D:\\DB\\tms01p141_log.ldf')FORATTACH;GO 權限不夠不能執行的話請自行開放。 CREATETABLESUB(FOLDERint)--建一個臨時Table放id INSERTINTOSUBSELECTTOP10--筆數條件 B.idasFOLDERFROMBinderasB,DocumentasD,Document_AttachmentasDA,AttachmentasAWhereB.currentDoc_id=D.idANDD.id=DA.doc_idANDDA.at_id=A.idDECLARE@SQLIMGVARCHAR(MAX),@RAW_DATAVARBINARY(MAX),--檔案二進位資料欄位(存放rawdata) @FILENAMEVARCHAR(MAX),--檔名欄位(記錄上傳檔名) @PATHVARCHAR(MAX),--最底層路徑 @FOLDERVARCHAR(MAX),--資料夾 @FILEIDVARCHAR(MAX),--不重要 @ObjectTokenINT,@cmdpathnvarchar(60)--命令列 SET@PATH='D:\\'--設定最底層路徑 --建資料夾BEGIN DECLAREC_SUBCURSORFAST_FORWARDFORSELECTFOLDERFROMSUBgroupbyFOLDEROPENC_SUBFETCHNEXTFROMC_SUBINTO@FOLDERWHILE@@FETCH_STATUS=0BEGINSET@FOLDER=@PATH+@FOLDER;--設定路徑 SET@cmdpath='MD '+@FOLDEREXECmaster.dbo.xp_cmdshell@cmdpathFETCHNEXTFROMC_SUBINTO@FOLDERENDCLOSEC_SUBDEALLOCATEC_SUB--建資料夾END DECLAREFILESCURSORFAST_FORWARDFORSELECTTOP10--筆數條件 B.idasFOLDER,A.idasFileId,A.fileNameasFILENAME,A.rawDataasRAW_DATAFROMBinderasB,DocumentasD,Document_AttachmentasDA,AttachmentasAWhereB.currentDoc_id=D.idANDD.id=DA.doc_idANDDA.at_id=A.id---選擇欲轉出的資料(選擇rawdata跟檔名欄位) OPENFILESFETCHNEXTFROMFILESINTO@FOLDER,@FILEID,@FILENAME,@RAW_DATAWHILE@@FETCH_STATUS=0BEGINSET@FOLDER=@PATH+@FOLDER;--設定路徑 --SET @cmdpath = 'MD ' + @FOLDER --EXEC master.dbo.xp_cmdshell @cmdpath SET@FILENAME=@FOLDER+'\\'+@FILENAMEPRINT@FILENAME--PRINT @SQLIMG EXECsp_OACreate'ADODB.Stream',@ObjectTokenOUTPUTEXECsp_OASetProperty@ObjectToken,'Type',1EXECsp_OAMethod@ObjectToken,'Open'EXECsp_OAMethod@ObjectToken,'Write',NULL,@RAW_DATAEXECsp_OAMethod@ObjectToken,'SaveToFile',NULL,@FILENAME,2EXECsp_OAMethod@ObjectToken,'Close'EXECsp_OADestroy@ObjectTokenFETCHNEXTFROMFILESINTO@FOLDER,@FILEID,@FILENAME,@RAW_DATAENDCLOSEFILESDEALLOCATEFILESDROPTABLESUB ","date":"2022-03-21 00:12:00 Monday","objectID":"/posts/2022/covert-to-files-from-mssql/:0:0","tags":["MSSQL"],"title":"將MSSQL Table的Binary檔轉出","uri":"/posts/2022/covert-to-files-from-mssql/"},{"categories":null,"content":"第一篇文章","date":"2022-03-20 00:12:00 Sunday","objectID":"/posts/2022/first-post/","tags":["trifles"],"title":"第一篇","uri":"/posts/2022/first-post/"},{"categories":null,"content":"就試看看吧？ 年紀越大記憶力越差， 想記錄一些可能曾經碰過或可能會用得到的東西，算是雜物儲藏庫吧！ ","date":"2022-03-20 00:12:00 Sunday","objectID":"/posts/2022/first-post/:0:0","tags":["trifles"],"title":"第一篇","uri":"/posts/2022/first-post/"},{"categories":null,"content":"不學無術，混死等死，記憶衰退，只能把可能有用的東西記錄下來。 ","date":"2019-03-12 17:05:52 Tuesday","objectID":"/about/:0:0","tags":null,"title":"關於我","uri":"/about/"}]