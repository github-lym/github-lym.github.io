[{"content":"駐點在機關時得幫其他廠商定期與不定期更新網站。\n更新這件事是沒什麼問題，廠商已經盡量簡化，編譯包版後執行批次檔就可以了。\n只不過就是批次檔有點多，每個網站一個近40個。\n負責上版的主機效能的很棒，可以一次執行20個左右沒問題。\n但Windows有個內建設定─不得一次執行超過15個批次檔，\n這樣本可兩次跑完卻分三次跑，不是很願意。\n雖這可以藉由改登錄檔處理，但在公家機關的主機改登錄檔怕會有些不必要的麻煩。\n且每個批次檔要截圖為證。\n這就有點麻煩，那麼多個視窗，一個不小心就漏了或搞不清是否已擷過圖。\n於是就寫了這個程式，\n既可以多線程大量執行批次檔，且可以讓批次檔視窗輪流跑到最前端並擷圖。\n 後來發現有時批次檔執行不見得會成功，\n但程式截圖那時根本也不可能一一細看，\n最後改成把命令提示字元輸出導向成文字檔，\n事後再去檢查文字檔的訊息，\n若失敗就再一次執行相對應的批次檔。\n","permalink":"https://github-lym.github.io/posts/2022/focussnapshot/","summary":"\u003cp\u003e駐點在機關時得幫其他廠商定期與不定期更新網站。\u003c/p\u003e","title":"多線程執行批次檔並將視窗分別擷圖(導向輸出log)"},{"content":"做客服工程師那會，每天都要查詢資料庫。\n但資料庫有個欄位當初設計為char而非varchar，\n複製這欄位做之後的查詢還得去除掉後面的空白造成困擾。\n當時的想法是如果可以在剪貼簿上把前後空白刪掉就好了。 但即便對現在的我來說仍是有困難的，還好有得抄。\n找到類似的稍微改一下達到我要的，\n加上可以將程式縮到工作列與點擊切換啟動與否。\n//hide form from Alt-Tab dialog protected override CreateParams CreateParams { get { // Turn on WS_EX_TOOLWINDOW style bit CreateParams cp = base.CreateParams; cp.ExStyle |= 0x80; return cp; } } //form invisible protected override void OnVisibleChanged(EventArgs e) { base.OnVisibleChanged(e); this.Visible = false; } public Form1() { InitializeComponent(); nextClipboardViewer = (IntPtr)SetClipboardViewer((int)this.Handle); //this.ShowInTaskbar = false; //不顯示在底下工具列(改設定在form屬性) this.Hide(); //隱藏視窗 this.notifyIcon1.ContextMenu = new ContextMenu(); this.notifyIcon1.ContextMenu.MenuItems.Add(new MenuItem(\u0026#34;EXIT\u0026#34;, new EventHandler(Exit))); notifyIcon1.Icon = Properties.Resources.checkIcon; } private void notifyIcon1_MouseClick(object sender, MouseEventArgs e) { if (trimWorking == true) { trimWorking = false; notifyIcon1.Icon = Properties.Resources.unCheckIcon; notifyIcon1.ShowBalloonTip(100, null, \u0026#34;Stop Working\u0026#34;, ToolTipIcon.Warning); } else if (trimWorking == false) { trimWorking = true; notifyIcon1.Icon = Properties.Resources.checkIcon; notifyIcon1.ShowBalloonTip(100, null, \u0026#34;Start Working\u0026#34;, ToolTipIcon.Warning); } } private void Exit(object sender, EventArgs e) { this.Close(); } 雖然偶爾會跳出異常，不過方便多了。\n如今回過頭來看，還真的是有些地方可以改改看看還會不會跳出異常。\n","permalink":"https://github-lym.github.io/posts/2022/trimcopy/","summary":"\u003cp\u003e做客服工程師那會，每天都要查詢資料庫。\u003c/p\u003e","title":"去掉文字前後空白"},{"content":"之前有聽過forfiles的大名，但沒機會用。\n這次襄理要我寫個批次檔刪除IIS上的logs，只保留一個月內的。\n立刻著手抄研究一下。\n我當時照抄了一份也試了覺得可行，\n事後發現在有子資料夾的情況下，只有刪除檔案，不會刪除子資料夾。\n也發現子資料夾的時間都被改變了，可能是刪除檔案的關係。\nforfiles -p \u0026#34;D:\\logfiles\u0026#34; -m *.* -d -30 -c \u0026#34;cmd /c del /q @path\u0026#34; forfiles -p \u0026#34;D:\\logfiles\u0026#34; -d -30 -c \u0026#34;cmd /c IF @isdir == TRUE rd /S /Q @path\u0026#34; 到最後還是在網上找到答案。\n附上微軟官方說明。\n","permalink":"https://github-lym.github.io/posts/2022/del_logs_forfiles/","summary":"\u003cp\u003e之前有聽過forfiles的大名，但沒機會用。\u003c/p\u003e","title":"用forfiles刪除過期檔案"},{"content":"站台要更新之前一定得備份。\n之前土炮的作法，當然是在備份區建立一個日期資料夾，然後複製貼上。\n這麼做也不是不行，但logs資料其實沒必要備份，\n再加上使用windows複製不夠有效率，我又把腦筋動到了robocopy上。\n:@Echo Off Set \u0026#34;sd=C:\\inetpub\\CMS\u0026#34; Set \u0026#34;dd=C:\\inetpub\\CMS_BACKUP\u0026#34; Set \u0026#34;ex1=C:\\inetpub\\CMS\\WebApi\\Logs\u0026#34; :這段是用來產生當日日期 for /f \u0026#34;tokens=2 delims==\u0026#34; %%a in (\u0026#39;wmic OS Get localdatetime /value\u0026#39;) do set \u0026#34;dt=%%a\u0026#34; set \u0026#34;YY=%dt:~2,2%\u0026#34; \u0026amp; set \u0026#34;YYYY=%dt:~0,4%\u0026#34; \u0026amp; set \u0026#34;MM=%dt:~4,2%\u0026#34; \u0026amp; set \u0026#34;_DD=%dt:~6,2%\u0026#34; set \u0026#34;HH=%dt:~8,2%\u0026#34; \u0026amp; set \u0026#34;Min=%dt:~10,2%\u0026#34; \u0026amp; set \u0026#34;Sec=%dt:~12,2%\u0026#34; set \u0026#34;datestamp=%YYYY%%MM%%_DD%\u0026#34; \u0026amp; set \u0026#34;timestamp=%HH%%Min%%Sec%\u0026#34; \u0026amp; set \u0026#34;fullstamp=%YYYY%-%MM%-%_DD%_%HH%%Min%-%Sec%\u0026#34; :echo datestamp: \u0026#34;%datestamp%\u0026#34; :echo timestamp: \u0026#34;%timestamp%\u0026#34; :echo fullstamp: \u0026#34;%fullstamp%\u0026#34; RoboCopy \u0026#34;%sd%\u0026#34; \u0026#34;%dd%\\CMS_BACKUP_%datestamp%\\CMS\u0026#34; /MIR /E /R:5 /W:5 /TBD /NP /NFL /V /MT:32 /XD \u0026#34;%ex1%\u0026#34; pause 一開始就設定好來源與目標，還有排除的資料夾。\n/mir 鏡像目錄樹狀結構 (相當於 /e plus /purge) 。 使用這個選項搭配 /e 選項和目的地目錄，會覆寫目的地目錄安全性設定。 /e\t複製子目錄。 此選項會自動包含空的目錄。 /s\t複製子目錄。 此選項會自動排除空白目錄。 /r:\u0026lt;n\u0026gt;\t指定失敗複製的重試次數。N的預設值為 1000000 (1000000 重試) /w:\u0026lt;n\u0026gt;\t指定重試之間的等待時間 (以秒為單位)。 N的預設值是 30 (等候時間30秒) /tbd 指定系統將等待定義共用名稱 (重試錯誤 67) 。 :看不懂，英文是寫這樣 `Wait for share names To Be Defined (retry error 67)\r/np 指定將不會顯示複製作業的進度 (到目前為止複製的檔案或目錄數目)。` 速度比較快 /nfl 指定不會記錄檔案名稱。\r/v\t產生詳細資訊輸出，並顯示所有略過的檔案。\r/MT[:n]\t使用 n 個執行緒建立多執行緒複製。\r/xd \u0026lt;directory\u0026gt;[ ...]\t排除符合指定名稱和路徑的目錄。 其實在寫這篇我才比較了解，還有用錯的。\n還是去微軟官方看比較詳盡。\n","permalink":"https://github-lym.github.io/posts/2022/website_backup/","summary":"\u003cp\u003e站台要更新之前一定得備份。\u003c/p\u003e","title":"使用robocopy站台備份"},{"content":"MSSQL資料庫每天都會備份，每週一得還原最新備份在另一台當歷史資料查詢。\n通常資料庫備份容量不會太小，\n當時每週一早上都先進機房後，再花個一二十分鐘下載到指定主機再還原。\n一整個流程下來都要花個三四十分鐘。\n覺得這時間頗浪費，於是懶人病發作寫了這個當排程。 讓我可以在進機房之前就把備份檔下載好，起碼省去一半的時間。\n微軟這邊有上傳詳細教學：\nusing System; using System.IO; using System.Net; namespace Examples.System.Net { public class WebRequestGetExample { public static async Task Main() { // Get the object used to communicate with the server. FtpWebRequest request = (FtpWebRequest)WebRequest.Create(\u0026#34;ftp://www.contoso.com/test.htm\u0026#34;); request.Method = WebRequestMethods.Ftp.UploadFile; // This example assumes the FTP site uses anonymous logon. request.Credentials = new NetworkCredential(\u0026#34;anonymous\u0026#34;, \u0026#34;janeDoe@contoso.com\u0026#34;); // Copy the contents of the file to the request stream. await using FileStream fileStream = File.Open(\u0026#34;testfile.txt\u0026#34;, FileMode.Open, FileAccess.Read); await using Stream requestStream = request.GetRequestStream(); await fileStream.CopyToAsync(requestStream); using FtpWebResponse response = (FtpWebResponse)request.GetResponse(); Console.WriteLine($\u0026#34;Upload File Complete, status {response.StatusDescription}\u0026#34;); } } } 我是下載，所以\nrequest.Method = WebRequestMethods.Ftp.ListDirectory;\n使用binary傳輸\nrequest.UseBinary = true;\n","permalink":"https://github-lym.github.io/posts/2022/ftpdb/","summary":"\u003cp\u003eMSSQL資料庫每天都會備份，每週一得還原最新備份在另一台當歷史資料查詢。\u003c/p\u003e","title":"以FTP抓取資料庫備份"},{"content":"因代理同事工作，才知道他每天需記錄排程是否順利。\n要特地進機房看某主機排程是否有順利進行。\n因資安問題並沒有開放遠端連線，所以只能用這種沒效率的方法。\n我就找資料寫了這程式。\n可以指定排程名稱產生log。\n再用FTP連到該主機看該log(好在FTP沒被禁)，省去進機房的麻煩。\n\n 取得排程資料\nTaskService taskService = new TaskService(); TaskCollection taskCollection = taskService.GetFolder(@\u0026#34;\\\u0026#34;).GetTasks(); log.WriteLine(\u0026#34;排程:{0},執行狀態:{1}\u0026#34;, taskCollection[j].Name, taskCollection[j].LastTaskResult); log.WriteLine(\u0026#34;最後執行時間:{0},下次執行時間:{1}\u0026#34;, taskCollection[j].LastRunTime, taskCollection[j].NextRunTime.ToString()); ","permalink":"https://github-lym.github.io/posts/2022/taskscheduler/","summary":"\u003cp\u003e因代理同事工作，才知道他每天需記錄排程是否順利。\u003c/p\u003e","title":"查詢排程狀態"},{"content":"因代理同事工作，才知道他每天得特地進機房看某主機的硬碟剩餘空間。\n沒辦法，一樣沒有遠端連線可直接登入觀看。\n可以秀出磁碟空間的寫法，MSDN就有資料所以直接照抄。 好在FTP沒被擋，可排程產生log，再用FTP連到該主機看。 \n 取得磁碟資料\nDriveInfo[] allDrives = DriveInfo.GetDrives(); 列出\nforeach (DriveInfo d in allDrives) { if (!File.Exists(logFullPath)) log = new StreamWriter(logFullPath); else log = File.AppendText(logFullPath); log.WriteLine(\u0026#34;Drive {0}\u0026#34;, d.Name); log.WriteLine(\u0026#34; Drive type: {0}\u0026#34;, d.DriveType); if (d.IsReady == true) { log.WriteLine(\u0026#34; Volume label: {0}\u0026#34;, d.VolumeLabel); log.WriteLine(\u0026#34; File system: {0}\u0026#34;, d.DriveFormat); gb = (float)(d.TotalSize / 1073741824d); log.WriteLine( \u0026#34; Total size of drive: {0, 15} GBs\u0026#34;, gb); gb = (float)((d.TotalSize - d.AvailableFreeSpace) / 1073741824d); log.WriteLine( \u0026#34; Used space: {0, 15} GBs\u0026#34;, gb); gb = (float)(d.TotalFreeSpace / 1073741824d); log.WriteLine( \u0026#34; Total available space: {0, 15} GBs\u0026#34;, gb); log.WriteLine(\u0026#34;\u0026#34;); } ","permalink":"https://github-lym.github.io/posts/2022/drivefreespace/","summary":"\u003cp\u003e因代理同事工作，才知道他每天得特地進機房看某主機的硬碟剩餘空間。\u003c/p\u003e","title":"查詢磁碟容量"},{"content":"有個系統每天產生的log檔很多。\n\n同樣的，居然沒有以日期資料夾分類整理。\n隨著日子過去就越積越多，為了查log光開啟資料夾顯示所有檔案就要等很久。\n就寫這程式每天判斷並把log放到依月份的資料夾。要查也方便。\n純粹是看不慣log的資料夾塞得滿滿的從沒整理。","permalink":"https://github-lym.github.io/posts/2022/arrangelog/","summary":"\u003cp\u003e有個系統每天產生的log檔很多。\u003c/p\u003e","title":"整理logs"},{"content":"維護的系統有提供上傳附件的功能。\n也不意外，這功能是一般系統都會有的功能。\n大概是開發者沒想過這系統會用那麼久，\n上傳的目錄並無額外子目錄，就把所有檔案像大雜燴一樣統統塞一起。\n因塞久了硬碟會滿，就得把較舊的檔案搬移。\n但一進入資料夾因為檔案太多就快死機了；\n為了要備份較舊檔案，檔案開啟後以時間排序又要死一次。\n系統的上傳程式我改不了，那我讓備份這邊的輕鬆點，就生出了這程式。\n可以指定路徑並依檔案時間判斷移到另一指定路徑，\n不再開啟資料夾浪費時間。 下方圖片為後來進階版。\n全部重寫後效能應有增加，並且增加了依月份產生資料夾功能。\n還很騷包附上了進度條(ProgressBar)。 當然啦，現在有robocopy應該就比較方便了。\n","permalink":"https://github-lym.github.io/posts/2022/copytofolder/","summary":"\u003cp\u003e維護的系統有提供上傳附件的功能。\u003cbr\u003e\n也不意外，這功能是一般系統都會有的功能。\u003c/p\u003e","title":"指定目錄搬移大量檔案"},{"content":"剛進公司是駐點在公家機關做客服工程師，每天接電話回答系統問題。\n除此之外，每天下班為了流程都必須更新該機關組織圖。\n前輩寫了一個很神的程式，他寫的vbs可以去抓資料庫的資料，\n並產生新的SQL指令(文字檔)可以更新組織圖。\n所以我們每天會檢查有異動的組織單位，產生該組織的SQL更新指令。 這產生的問題比較麻煩的點有兩個：\n1. 有時資料庫連不上或是一些我不知道的理由，產生的SQL指令並不完全。 2. 要開啟多個文字檔執行SQL指令，頗浪費時間。做完一整套常花快一個鐘頭。  於是，我的懶人病發作了，就寫了進公司的第一支程式。 一開始很單純，既然程式在有異動單位的資料夾產生*.sql檔，\n那我把子資料夾的檔案合併成一個再來執行就好。\n於是生成了這個。\n雖省了一些時間，但並沒解決上述第一個問題。\n上圖後來東問西抄問人寫出來的第三版。\n當時從Leo那得知執行vbs的寫法：\nprivate void _vbs(DirectoryInfo _folder) //執行子目錄底下vbs { vbsfile = _folder.FullName + \u0026#34;\\\\\u0026#34; + set.VBSname; Process vbs = new Process(); vbs.StartInfo.FileName = @\u0026#34;cscript\u0026#34;; vbs.StartInfo.Arguments = \u0026#34; \u0026#34; + vbsfile; vbs.StartInfo.WorkingDirectory = _folder.FullName; vbs.Start(); vbs.WaitForExit(); vbs.Close(); //System.Threading.Thread.Sleep(TimeSpan.FromTicks(set.waitTime)); } \n比以前的作業方式簡單又可檢查未產生的檔案並重新產出，\n算是個半全自動程式。 以前產生百個檔案以上無法一一檢查的問題迎刃而解，\n使用這版本以來，不再有未產出檔案的事發生。\n但僅適用於本人上班場所，泛用性不高。 不過省了很多時間，本來一小時的操作變為大約20分鐘左右就搞定下班了。\n","permalink":"https://github-lym.github.io/posts/2022/ntpc-organizational-chart/","summary":"\u003cp\u003e剛進公司是駐點在公家機關做客服工程師，每天接電話回答系統問題。\u003c/p\u003e\n\u003cp\u003e除此之外，每天下班為了流程都必須更新該機關組織圖。\u003c/p\u003e","title":"批次執行vbs檔並檢查結果"},{"content":"當時臨時接到這個要求。\n先掛載到Server\n 因Express無法掛超過10GB，請用其他進階版本。\n USE[master]GOCREATEDATABASE[tms01p141]ON(FILENAME=N\u0026#39;D:\\DB\\tms01p141.mdf\u0026#39;),(FILENAME=N\u0026#39;D:\\DB\\tms01p141_log.ldf\u0026#39;)FORATTACH;GO 權限不夠不能執行的話請自行開放。\n CREATETABLESUB(FOLDERint)--建一個臨時Table放id INSERTINTOSUBSELECTTOP10--筆數條件 B.idasFOLDERFROMBinderasB,DocumentasD,Document_AttachmentasDA,AttachmentasAWhereB.currentDoc_id=D.idANDD.id=DA.doc_idANDDA.at_id=A.idDECLARE@SQLIMGVARCHAR(MAX),@RAW_DATAVARBINARY(MAX),--檔案二進位資料欄位(存放rawdata) @FILENAMEVARCHAR(MAX),--檔名欄位(記錄上傳檔名) @PATHVARCHAR(MAX),--最底層路徑 @FOLDERVARCHAR(MAX),--資料夾 @FILEIDVARCHAR(MAX),--不重要 @ObjectTokenINT,@cmdpathnvarchar(60)--命令列 SET@PATH=\u0026#39;D:\\\u0026#39;--設定最底層路徑 --建資料夾BEGIN DECLAREC_SUBCURSORFAST_FORWARDFORSELECTFOLDERFROMSUBgroupbyFOLDEROPENC_SUBFETCHNEXTFROMC_SUBINTO@FOLDERWHILE@@FETCH_STATUS=0BEGINSET@FOLDER=@PATH+@FOLDER;--設定路徑 SET@cmdpath=\u0026#39;MD \u0026#39;+@FOLDEREXECmaster.dbo.xp_cmdshell@cmdpathFETCHNEXTFROMC_SUBINTO@FOLDERENDCLOSEC_SUBDEALLOCATEC_SUB--建資料夾END DECLAREFILESCURSORFAST_FORWARDFORSELECTTOP10--筆數條件 B.idasFOLDER,A.idasFileId,A.fileNameasFILENAME,A.rawDataasRAW_DATAFROMBinderasB,DocumentasD,Document_AttachmentasDA,AttachmentasAWhereB.currentDoc_id=D.idANDD.id=DA.doc_idANDDA.at_id=A.id---選擇欲轉出的資料(選擇rawdata跟檔名欄位) OPENFILESFETCHNEXTFROMFILESINTO@FOLDER,@FILEID,@FILENAME,@RAW_DATAWHILE@@FETCH_STATUS=0BEGINSET@FOLDER=@PATH+@FOLDER;--設定路徑 --SET @cmdpath = \u0026#39;MD \u0026#39; + @FOLDER --EXEC master.dbo.xp_cmdshell @cmdpath SET@FILENAME=@FOLDER+\u0026#39;\\\u0026#39;+@FILENAMEPRINT@FILENAME--PRINT @SQLIMG EXECsp_OACreate\u0026#39;ADODB.Stream\u0026#39;,@ObjectTokenOUTPUTEXECsp_OASetProperty@ObjectToken,\u0026#39;Type\u0026#39;,1EXECsp_OAMethod@ObjectToken,\u0026#39;Open\u0026#39;EXECsp_OAMethod@ObjectToken,\u0026#39;Write\u0026#39;,NULL,@RAW_DATAEXECsp_OAMethod@ObjectToken,\u0026#39;SaveToFile\u0026#39;,NULL,@FILENAME,2EXECsp_OAMethod@ObjectToken,\u0026#39;Close\u0026#39;EXECsp_OADestroy@ObjectTokenFETCHNEXTFROMFILESINTO@FOLDER,@FILEID,@FILENAME,@RAW_DATAENDCLOSEFILESDEALLOCATEFILESDROPTABLESUB","permalink":"https://github-lym.github.io/posts/2022/covert-to-files-from-mssql/","summary":"\u003cp\u003e當時臨時接到這個要求。\u003c/p\u003e","title":"將MSSQL Table的Binary檔轉出"},{"content":"就試看看吧？\n年紀越大記憶力越差，\n想記錄一些可能曾經碰過或可能會用得到的東西，算是雜物儲藏庫吧！ ","permalink":"https://github-lym.github.io/posts/2022/first-post/","summary":"\u003cp\u003e就試看看吧？\u003c/p\u003e","title":"第一篇"},{"content":"不學無術，混死等死，記憶衰退，只能把可能有用的東西記錄下來。 ","permalink":"https://github-lym.github.io/about/","summary":"不學無術，混死等死，記憶衰退，只能把可能有用的東西記錄下來。 ","title":"關於我"}]